# Additional Tools for SPROUT
- [Optional Tools](#optional-tools)
- [Visualize by Meshes](#visualize-by-meshes)
- [Avizo Addons](#avizo-addons)
- [ImageJ Macros](#imagej-macros)

## Optional Tools
1. **MeshLab**  
   - MeshLab is a tool for viewing 3D meshes generated by SPROUT.

2. **Optional Visualization Tools**  
   - 3D: Tools like **DragonFly** or **Avizo** can be used to visualize and manipulate SPROUT's segmentation results.
   - 2D: Tools like **ImageJ** can be used to visualize and manipulate SPROUT's 2D segmentation results.

## Visualize by Meshes
SPROUT provide scripts to generate meshes for visualisation.

### **`make_mesh.py`**
Generates meshes for segmentations.
   - **Usage**:
      - Run with the default configuration:  
         ```bash
         python make_mesh.py  
         ```
         *(Reads the `./make_mesh.yaml` file)*  
      - Run with a custom configuration:  
         ```bash
         python make_mesh.py <config>.yaml  
         ```
      - Run with a custom configuration:  
         ```bash
         python make_mesh.py ./template/make_mesh.yaml
         ```
      An example YAML configuration file is available at `./template/make_mesh.yaml`, which generates meshes for the grown results from the example in the `PipelineGrow.py`

   - **Key Parameters**:  
      - `img_path`: Path to the input segmentation. (Specify **either** `img_path` or `input_folder`)  
      - `input_folder`: A folder containing multiple segmentations.  
      - `output_folder`: Directory where the generated meshes will be saved. 
      - `num_threads`: Number of threads for parallel processing.  
      - `downsample_scale`: Mesh simplification factor (*higher values reduce mesh complexity*).
      - `step_size`: Controls the **marching cubes** mesh reconstruction (*1 = original size; higher values generate simpler meshes*).  
  
  - **Outputs**, For each **input segmentation**, a corresponding folder (matching the segmentation filename) will be created, containing:  
      - **Individual Meshes** (`.ply` format)  
         - Example: `1.ply`, `2.ply`, `3.ply` (each representing a separate segmentation class).  
      - **Merged Meshes**  
         - `merged.ply`: Combined mesh of all classes.  
         - `merged_n_to_m.ply`: Merged meshes for **class groups (e.g., classes 1–10, 11–20, etc.)**.  

Meshes use a 10-color cyclic colormap, where class IDs 1–10 map to distinct colors and repeat for IDs beyond 10.  
![Color Map](./material/colourmap.png)


## Avizo Addons
Addon scripts are saved in `./avizo` folder. 
Change the extension from `py` to `pyscro`, and drag into AVIZO's `Project View` to use it.

### **`PreProcess.py`**  
It is a script designed for pre-processing images based on the skull-suture workflow. It simplifies the pre-processing pipeline by combining multiple functions into a single add-on, eliminating the need to open multiple functions in AVIZO. 

When setting up the input in the add-on UI, the following operations can be performed:
- **Cropping**: Define a region of interest to focus on specific parts of the image.
- **Swapping Axes**: Reorient the volume by swapping axes as needed.
- **Resampling**: Scale voxel sizes to adjust the resolution of the dataset.
- **Converting to 8-bit**: Reduce the bit depth of the image for standardization or compatibility.

Additionally, it automatically creates all essential objects useful for preprocessing, such as:
- Volume rendering
- Ortho-slices
- Axes
- Bounding boxes

**Transformations (e.g., rotations)** are not currently supported and must be performed separately.

### **`LoadVisFiles.py`**  

It is a script designed to batch process and visualize segmentation labels in AVIZO.

- **Batch Loading and Conversion**: Load and convert 8-bit segmentation labels into AVIZO in a single batch, streamlining the workflow. Supports reordering material/class IDs based on size using AVIZO's `reorder` function. Some AVIZO versions may not support the reorder function. In such cases, simply untick the reorder option during processing.
- **Visualization Options**: Provides options for visualizing segmentation labels in either voxel or mesh format, enabling flexible data exploration.
- **Material Name Mapping**: Outputs the relationship between material names and their corresponding segmentation classes, ensuring clarity and traceability during visualization.

### **`Edit.py`**  

Performs the same tasks described in the Helper Functions for Editing section, combining multiple editing operations into a single script for convenience.

---

## **ImageJ Macros**  

SPROUT provides ImageJ macros (`.ijm` files) in the `./plugins` folder to facilitate segmentation visualization and editing within ImageJ. These macros are **recommended for use with 2D images**.  

You can either **run the scripts directly in the Macro Editor** or **install the `.ijm` files** for easier access. Refer to the official ImageJ [documentation](https://imagej.net/ij/developer/macro/macros.html) for detailed instructions on macro installation and usage.  

### **`load_vis_results.ijm`**  
This macro loads and colorizes all image files in a selected folder using the `glasbey` color lookup table (`LUT`). It is useful for quickly visualizing multiple segmentation results (e.g., seeds and grown results) in ImageJ.  
 
  - Asks for an input folder containing segmentation results  
  - Loads all images in the folder into ImageJ  
  - Applies `Lookup Tables` → `glasbey` for colorized segmentation display  

### **`SPROUT_edit.ijm`**  
This macro allows users to manually edit segmentation masks in ImageJ using the `Multi-point tool` providing an intuitive way to refine **seeds** and **grown results**. 
1. Users can select regions of interest with the `Multi-point tool` and apply the following operations:  
   1. **Merge segmentation classes**: Combine selected segments into a single class.  
   2. **Convert selected segments to background**: Remove unwanted regions by setting them as background.  
   3. **Keep only selected regions**: Retain only the chosen areas and set all other segments as background.  
2. Users can use ROI tools like rectangle, polygon and free-hand to select regions and get the selected regions into user-input value. Then a split connected components can be performed, if users separate a region into multiple.   
