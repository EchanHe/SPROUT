# SPROUT (Semi-automated Parcellation of Region Outputs Using Thresholding and Transformation): an adaptable computer vision tool to generate 3D segmentations

SPROUT: Semi-automated Parcellation of Region Outputs Using Thresholding and Transformation
This package is for parcellating segments from 3D scans (e.g. micro-CT and MRI scans) using semi-automoated seed generation and growth. It can be applied to diverse datasets, from skulls and entire skeletons (e.g. to isolate individual bones) to organs and even man-made structures (e.g. concrete blocks).  Example applications and method details are provided in Y. He, M. Camaiti, L.E. Roberts, J.M. Mulqueeney, M. Didziokas, A. Goswami. 2024. Introducing SPROUT (Semi-automated Parcellation of Region Outputs Using Thresholding and Transformation): an adaptable computer vision tool to generate 3D segmentations. Bioarxiv, xx.

This approach and code are highly inspired by BounTI (M. Didziokas, E. Pauws, L. Kölby, R. H. Khonsari, M. Moazen. 2024. BounTI (boundary-preserving threshold iteration): A user-friendly tool for automatic hard tissue segmentation. Journal of Anatomy 245, 829–841).


## Prerequisites

1. **Python and Environment Setup**
   - **Install Python**: If Python is not already installed, we recommend downloading the [Anaconda distribution](https://www.anaconda.com/products/distribution). After providing your email, follow the download link and select the version suitable for your operating system.
   - **Set up Python Environment**:
     - For Windows users with Anaconda, open the **Anaconda Prompt** from the Start menu.
     - For other installations, open a terminal with Python access.

2. **Create and Configure Python Environment**
   - SPROUT supports **Python 3.10**. Required libraries and versions are:
     ```
     NumPy: 1.26.4
     Pandas: 2.2.1
     Scikit-image: 0.22.0
     Tifffile: 2024.2.12
     Pyyaml: 6.0.1
     Trimesh: 4.3.1
     Matplotlib: 3.8.3
     open3d: 0.18.0
     ```
   - Steps to create the environment:
     1. **Create the environment**:
        ```bash
        conda create -n sprout python=3.10
        ```
     2. **Activate the environment**:
        ```bash
        conda activate sprout
        ```
     3. **Install dependencies**:
        ```bash
        pip install numpy==1.26.4 pandas==2.2.1 scikit-image==0.22.0 tifffile==2024.2.12 pyyaml==6.0.1 trimesh==4.3.1 matplotlib==3.8.3 open3d==0.18.0
        ```

### Recommended Tools

1. **MeshLab**  
   - MeshLab is a tool for viewing meshes generated by SPROUT.

2. **Optional Visualization Tools**  
   - Tools like **DragonFly** or **Avizo** can be used to visualize and manipulate SPROUT's segmentation results.


## Usage

### 1. Generate seeds
Use morphological transformations and connected components (initial segmentations for grow)
    
1. `make_seeds.py` is the for generating seeds. Config file template: `make_seeds.yaml` 
    - workspace: The workspace folder. All below files and folders are based on the workspace
    - file_name: path to input image
    - num_threads: multiple threads, recommend to match the number of target_thresholds
    - target_thresholds: For images, it's a threshold for segmenting the images. For binary segmentation, depending on the type, set 0 or 255 .
    - ero_iters: Iterations for erosion
    - segments: Integer >=1, The algorithm keeps top <segments> largest disconnected components
    - output_seed_folder: The folder name of output seeds
    - output_log_file: Name of the output file name
    - footprints: The way you want to erode your images, current supports 'ball' and 'cube' :Erosion all directions. 'ball_XY', 'ball_XZ', 'ball_YZ': Erosion on the Plane. 'X', 'Y', 'Z': Erosion on the axis.

    <br>

2. `make_seeds_all.py`, use the similar config except for `footprints`. As it generates seeds using 'ball', 'ball_XY', 'ball_XZ', 'ball_YZ'. And seeds are saved in subfolders with names match the footprint names.

3. `make_seeds_merged.py` is the algorithm for generating seeds for automating merge seeds generated. This algorithm can detect separations of a segmented region, and also keep regions that might be segmented out during the further seed generation.

Parameters need to be set on rules to detect the separations, and rules to keep segmented regions.


### 2. Grow

1. `make_grow_result.py` To grow the seeds to back to the original images with thresholds, or grow back to the binary segmentation<br>. Config file template: `make_grow_result.yaml`. 
    - workspace: The workspace folder. All below files and folders are based on the workspace
    - img_path: Input image
    - seg_path: The path of the seed
    - thresholds: A list of thresholds, normally from high to low. The algorithm will grow on higher thresholds first, then to lower.
    - dilate_iters: A list of integer. The dilation iteration for each threshold
    - touch_rule: Currently just set it as "stop"
    - to_grow_ids: Can specify classes to grow.
    - save_interval: Save the grow result for every <save_interval> interval

    <br>
    <br>
    Growing from high (can grow to less regions) to low (can grow to more regions) can prevent growing straight on the final result (i.e., the optimal threshold), as it would often causing some parts will overgrown on other parts. Making graduate grow, it can lower the chances of the overgrown problem.
    <br>
    <br>
    Supports early stopping. For a given grow iteration (e.g., 10 iters), if there aren't a minimum increase (default: 50 voxel) on size after growing for a consecutive iterations (default: 3 consecutive iterations), 

### 3. Visualization

1. `make_mesh.py` Create a mesh for every class for the input seed/result<br>
Can change `make_mesh.yaml` values to set the input, and output directory
A folder of seeds/results
One seed/result
<br>
<br>
Output includes components `ply` meshes with its segmentation id. e.g. `1.ply`, `2.ply`. A `merged.ply` with all the meshes combined. And files called `merged_n_to_m`, merged mesh with only including the mesh colours for every 10 classes from n to m.

    
2. `plot_mesh.py` Plot Generated meshes. <br>
TODO: Currently under testing

The current colourmap has 10 colours, mesh colours follow its order mapping the segmentation class 1-10, and recur using them after more than 11. ![Color Map](./material/colourmap.png)


### 4. Parallelization Support

All SPROUT scripts (`make_seeds.py`, `make_seeds_all.py`, `make_seeds_merged.py`, `make_grow_result.py`, `make_mesh.py`) support **parallelization** using Python's `threading` library. This allows for faster execution by distributing tasks across multiple threads.

- **How It Works**:  
  You can specify the number of threads in the configuration file (`num_threads`). By utilizing multiple threads, the scripts can process data simultaneously, significantly improving efficiency for large datasets or computationally intensive tasks.

- **Recommendation**:  
  For optimal performance, set `num_threads` to match the number of CPU cores on your system.



### Tutorial

A detailed tutorial with step-by-step instructions and screenshots is available in the [`./material/`](./material/) directory.

Demo data for the tutorial can be found in the [`./data/`](./data/) directory.

### Pipelines

1. Seed generation and making meshes. Run `./PipelineSeedMesh.py`, and an example config file is `./PipelineSeedMesh.yaml`

2. Growing and making meshes. Run `./PipelineGrowMesh.py`, and an example config file is `./PipelineGrowMesh.yaml`

2. Seed generation, growing and making meshes. Run `PipelineSeedGrowMesh.py`, currently is used for foram chamber separation.

4. Seed Generation by given a list of input arguements for `make_seeds` or `make_seeds_all`

### Filter Seeds/Results using segmentation stats
TODO This is used to filter out seeds that are not likely to be checked.
Working on the `./seeds_stats.py`, and based on the method in `./make_seeds_foram.py` and `./make_seeds_merged.py`.

### Editing tool
- For a given segmentation, merge multiple classes into one class. 
- Merge two segmentations, using specify classes for these two segmentations.
- Give a class, get all disconnected components, and keep the top-n (user defined) largest components

### Avizo Addons
Addon scripts are saved in `./avizo` folder. 
Change the extension from `py` to `pyscro`, and drag into AVIZO's `Project View` to use it.

`PreProcess.py`. 
<br>
Pre-processing image based the skull-suture workflow.
<br>
Pre-process the image in one addon, without the need of open multiple functions in AVIZO.
<br>
Create all objects (vol ren, ortho-slice, axes, bounding boxes) for a data that are useful for preprocessing
<br>
Transforming is not supported need to be done separately
- Cropping
- Swapping axes
- Resample by scaling voxel size
- Convert image to 8-bit

`LoadVisFiles.py`  
- Load and convert 8-bit labels into Avizo in batch.
- Allow users to visualise the labels in voxel or mesh
- Print the the relation between material names and the actual segmentation classes. The current version should work fine.

TO CHECK: For the mat names and seg cls. The numbers in names (`data.parameters['materials']`) won't match the seg cls numbers (`np.unique(data.get_array())`). We assume for 0-n in array match the materials[0] to materials[1].

Bug: can't load the tiff label that is export by AVIZO
TODO: add voxel size, by downsample the images.

`Edit.py` 
- Same tasks as describe in the Editing tools section




### BounTI multithread implementation
`./BounTI/run_bounti_mp.py` is used to run BounTI and BounTI flood, with a list of initial thresholds. 

## Parallelization:
`make_mesh.py`, `make_seeds.py`, `make_seeds_foram.py`, `make_sutures` currently support running in multiple processes. Please check your CPU and set the right `num_threads` in the configuration file

### Helper functions: Unzip a list of morphosource zip files
`morphosource_unzip.ipynb` 
`morphosource_unzip.py` .
- Unzip all the `*.zip` files from a given folder (input folder) to a target folder
- Save the unzip log. zip file path, unzip path, whether the unzip is success.
Unzip all morphosource in a folder/

Morphosource file structure.


### Unzip Morphosource Zip Files

#### Scripts
- **Notebook**: `morphosource/morphosource_unzip.ipynb`
- **Python Script**: `morphosource/morphosource_unzip.py`

These scripts are designed to streamline the process of extracting Morphosource files within a folder.

#### Functionality
- Unzips all `*.zip` files from a specified input folder to a target output folder.
- Logs the following details for each unzip operation:
  - Path of the `.zip` file.
  - Path of the unzipped content.
  - Status of the operation (success or failure).


